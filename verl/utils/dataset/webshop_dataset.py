# Copyright 2024 Bytedance Ltd. and/or its affiliates
# Copyright 2023-2024 SGLang Team
# Copyright 2025 ModelBest Inc. and/or its affiliates
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import json
import os
import random
import sys
from typing import List, Dict, Any
from pathlib import Path

# Add the parent directory to sys.path to import from core
sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..', '..', '..', '..'))

from core.scenarios import WebShopScenario
from .rl_dataset import RLHFDataset

class WebShopDataset(RLHFDataset):
    """Custom dataset class for WebShop scenarios that converts scenario format to VERL format.
    
    This class extends VERL's RLHFDataset to handle WebShop scenarios by:
    1. Loading scenarios from JSON files instead of parquet
    2. Converting scenario format to VERL's expected format
    3. Starting with empty prompts (initial user message generated by user simulator)
    """

    def __init__(self, data_files: List[str], tokenizer, processor, config: Dict[str, Any]):
        """Initialize WebShopDataset.
        
        Args:
            data_files: List of scenario JSON file paths
            tokenizer: Tokenizer for text processing
            processor: Processor for multimodal data
            config: Configuration dictionary
        """
        self.scenarios = []
        self.scenarios_file = config.custom_cls.config.get("scenarios_file", None)
        
        # Load scenarios
        self._load_scenarios()
        
        # Convert scenarios to VERL format
        verl_data = self._convert_scenarios_to_verl_format()
        
        # Create temporary parquet files for parent class
        self._create_temp_parquet_files(verl_data)
        
        # Initialize parent class with temporary parquet files
        super().__init__(data_files=self.temp_parquet_files, tokenizer=tokenizer, processor=processor, config=config)
        
        # Clean up temporary files
        self._cleanup_temp_files()

    def _load_scenarios(self):
        """Load scenarios from JSON file. Assumes that full path to scenarios_file is provided in config."""
        scenarios_path = self.scenarios_file
        if not os.path.exists(scenarios_path):
            raise FileNotFoundError(f"Scenarios file not found: {scenarios_path}")
        
        with open(scenarios_path, "r") as f:
            scenarios_data = json.load(f)
        
        # Shuffle with fixed seed for reproducibility
        random.seed(233)
        random.shuffle(scenarios_data)
        
        # Convert to WebShopScenario objects
        for scenario_data in scenarios_data:
            try:
                scenario = WebShopScenario(scenario_data=scenario_data, args={})
                if scenario.validate_scenario_data():
                    self.scenarios.append(scenario)
            except Exception as e:
                print(f"Warning: Failed to load scenario {scenario_data.get('scenario_id', 'unknown')}: {e}")
        
        print(f"Loaded {len(self.scenarios)} WebShop scenarios")

    def _convert_scenarios_to_verl_format(self) -> List[Dict[str, Any]]:
        """Convert scenarios to VERL format.
        
        Returns:
            List of VERL-formatted data items
        """
        verl_data = []
        
        for idx, scenario in enumerate(self.scenarios):
            try:
                verl_item = self._create_verl_data_item(scenario, idx)
                verl_data.append(verl_item)
            except Exception as e:
                print(f"Warning: Failed to convert scenario {scenario.scenario_id}: {e}")
                continue
        
        return verl_data

    def _create_verl_data_item(self, scenario: WebShopScenario, idx: int) -> Dict[str, Any]:
        """Convert a single scenario to VERL data format.
        
        Args:
            scenario: WebShopScenario object
            idx: Index of the scenario
            
        Returns:
            VERL-formatted data item
        """
        return {
            "data_source": "webshop",
            "prompt": self._create_verl_prompt(scenario),
            "ability": "webshop",
            "reward_model": {
                "style": "interaction",
                "scenario_data": scenario.scenario_data
            },
            "extra_info": {
                "scenario_id": scenario.scenario_id,
                "category": scenario.category,
                "product_type": scenario.product_type,
                "price_upper": scenario.price_upper,
                "interaction_kwargs": {
                    "name": "webshop",
                    "scenario_index": idx,
                    "scenarios_file": self.scenarios_file
                }
            }
        }

    def _create_verl_prompt(self, scenario: WebShopScenario) -> List[Dict[str, str]]:
        """Convert a WebShop scenario to VERL prompt format.
        
        The prompt starts with a minimal system message since VERL expects
        at least one message. The initial user message will be generated
        by the user simulator during interaction.
        
        Args:
            scenario: WebShopScenario object
            
        Returns:
            List with minimal system message (initial user message generated during interaction)
        """
        # Return minimal prompt - VERL expects at least one message
        # The initial user message will be generated by user_simulator.get_user_utterance()
        return [
            {
                "role": "system",
                "content": "You are a helpful shopping assistant."
            }
        ]

    def _create_temp_parquet_files(self, verl_data: List[Dict[str, Any]]):
        """Create temporary parquet files for parent class initialization.
        
        Args:
            verl_data: List of VERL-formatted data items
        """
        import tempfile
        import pandas as pd
        
        # Create temporary directory
        self.temp_dir = tempfile.mkdtemp()
        
        # Create temporary parquet file
        temp_file = os.path.join(self.temp_dir, "temp_data.parquet")
        df = pd.DataFrame(verl_data)
        df.to_parquet(temp_file, index=False)
        
        self.temp_parquet_files = [temp_file]

    def _cleanup_temp_files(self):
        """Clean up temporary files."""
        if hasattr(self, 'temp_dir') and os.path.exists(self.temp_dir):
            import shutil
            shutil.rmtree(self.temp_dir)

    def __len__(self):
        """Return the number of scenarios."""
        return len(self.scenarios)

